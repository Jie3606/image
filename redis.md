# Redis是什么？

◼ 它是一种基于键值对的NoSQL数据库； 

◼ 它的值由多种数据结构及算法所组成

1. NoSQL泛指非关系型的数据库；
2. 可解释为“non-relational”、“Not Only SQL”。![image-20230609170148402](https://raw.githubusercontent.com/Jie3606/image/main/image-20230609170148402.png?token=AWOQ2IB5W2AJ7KSQMQF4EZTG6VLNI)



Redis有哪些优势？ 

优势 说明 

速度惊人 读写性能可达10万/秒（所有数据放在内存中 / 采用C语言实现 / 采用单线程架构） 

功能丰富 1. 键过期功能；2. 发布订阅功能；3. 支持Lua脚本和模块；4. 支持事务和流水线； 

可持久化 支持三种形式的持久化：1. RDB持久化；2. AOF持久化；3. RDB-AOF混合持久化； 

支持主从复制 通过主从复制，可以保留多个相同数据的副本，通过冗余存储来提高数据安全性； 

支持哨兵模式 哨兵可以自动发现故障节点，自动进行故障转移，从而构建出高可用的Redis服务； 

支持集群模式 集群是Redis的分布式解决方案，可以横向扩展其处理能力，并进行自动故障转移

# Redis的持久化

在redis当中，提供了两种数据持久化的方式，分别为**RDB**以及**AOF**，且Redis默认开启的数据持久化方式为RDB方式

## RDB持久化方案

可以在配置文件中配置Redis进行快照保存的时机：

```text
save [seconds] [changes] 
```

意为在seconds秒内如果发生了changes次数据修改，则进行一次RDB快照保存

## RDB方案优点

1. 对性能影响最小。Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。
2. 每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。
3. 使用RDB文件进行数据恢复比使用AOF要快很多。

##  RDB方案缺点

1. 快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据
2. 如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间，影响Redis对外提供服务的能力



## AOF持久化方案

采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。

AOF默认是关闭的，如要开启，进行如下配置：

```text
  # 第594行  
  appendonly  yes 
```

### 配置AOF

AOF提供了三种fsync配置：always/everysec/no，通过配置项[appendfsync]指定：

1. **appendfsync no**：不进行fsync，将flush文件的时机交给OS决定，速度最快
2. **appendfsync always**：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢
3. **appendfsync everysec**：折中的做法，交由后台线程每秒fsync一次

### AOF rewrite

随着AOF不断地记录写操作日志，因为所有的写操作都会记录，所以必定会出现一些无用的日志。大量无用的日志会让AOF文件过大，也会让数据恢复的时间过长。不过Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。

AOF rewrite可以通过BGREWRITEAOF命令触发，也可以配置Redis定期自动进行：

```text
  auto-aof-rewrite-percentage 100  //百分比
  auto-aof-rewrite-min-size 64mb  //达到64MB进行重写[后面的根据每次重写大小增长100%重写]
```

###  AOF优点

1. **最安全**，在启用appendfsync为always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据
2. AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复
3. **AOF文件易读，可修改**，在进行某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。

### AOF的缺点

1. AOF文件通常比RDB文件更大

2. 性能消耗比RDB高

3. 数据恢复速度比RDB慢

	Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：

	- AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响
	- AOF + fsync every second是比较好的折中方案，每秒fsync一次
	- AOF + fsync never会提供AOF持久化方案下的最优性能

	使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置

### RDB or AOF

每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟。
	
Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。
	第二章 Redis 事务

# Redis事务简介

Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

**总结说：Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令**

- **Redis事务没有隔离级别的概念**

批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。

- **Redis不保证原子性**

Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。

一个事务从开始到执行会经历以下三个阶段：

- 第一阶段：开始事务
- 第二阶段：命令入队
- 第三阶段：执行事务

- **Redis事务相关命令：**

- MULTI 开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令队列

- EXEC 执行事务中的所有操作命令

- DISCARD 取消事务，放弃执行事务块中的所有命令

- WATCH 监视一个或多个key，如果事务在执行前，这个key（或多个key）被其他命令修改，则事务被中断，不会执行事务中的任何命令

- UNWATCH 取消WATCH对所有key的监视

### 为什么Redis不支持事务回滚？

多数事务失败是由语法错误或者数据结构类型错误导致的，语法错误说明在命令入队前就进行检测的，而类型错误是在执行时检测的，Redis为提升性能而采用这种简单的事务，这是不同于关系型数据库的，特别要注意区分。Redis之所以保持这样简易的事务，完全是为了保证高并发下的核心问题——**性能**。